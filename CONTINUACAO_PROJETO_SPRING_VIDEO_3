Nome do vídeo: Oficina2_Spring_Algaworks_Vídeo3_Segurança_e_Deploy

Veremos:
	- Pesquisa de vinhos
	- Edição e Exclusão
	- Adicionar Segurança
	- Deploy na nuvem
	
- Colocando mensagem de sucesso.

	- Para começar é necessário acrescentar no html cadastro-vinho uma mensagem de sucesso, na verdade uma <div>.
	- Porém no controle ele faz um redirect assim que grava no banco, então é necessário acrescentar um recurso para que não se perca essa mensagem.
		- Esse recurso é o "redirectAttributes".
		- Ele deve ser inserido após a chamada do save para ter certeza que salvou no banco.
		
		- Após isso voltar no cadastro-vinho.html e verificar na div se existe alguma coisa nessa mensagem para ser exibida no browser.
			- Utilizando o objeto isEmpty do thymeleaf é possível fazer essa verificação e depois no <span> acrescentamos o th:text para exibir esse nosso
				redirectAttribute, ou seja, o conteúdo da mensagem.
				
			// *** no html
			<div class="alert  alert-success" th:if="${!#strings.isEmpty(mensagem)}">//se existir algo que não seja o isEmpty ele exibe a mensagem, "!#strings..."
				<span th:text="${mensagem}"></span> //exibindo o conteúdo da mensagem
			</div>
			
			// *** no controller
			@PostMapping("/vinhos/novo")
			public ModelAndView salvar(@Valid Vinho vinho, BindingResult result,
										RedirectAttributes attributes) { //declarando o RedirectAttibutes no cabeçalho
				if (result.hasErrors()) {
					 return novo(vinho);
				}		
				vinhos.save(vinho);
				attributes.addFlashAttribute("mensagem", "Vinho salvo com sucesso!");//preenchendo o attributes com a mensagem de sucesso
				
				return new ModelAndView("redirect:/vinhos/novo");
			}
			
			Esse redirectAttributes cria uma mini sessão para fazer esse trabalho para não perder a mensagem ao fazer o redirect.
				- Depois de salvar no banco e mostrar a mensagem o spring exibe na url um "jsessionid".
					- http://localhost:8080/vinhos/novo;jsessionid=3EBCC3C701A454034FF27C9B493DBD3D
					

- Partindo para a tela de pesquisa de vinhos. 

	- Nesse momento será possível ver que existe uma duplicidade de códigos e isso não é legal. Nesse momento será visto uma maneira de trabalhar melhor com o 
		layout e utilizar melhor os recursos do thymeleaf e deixar a aplicação mais enxuta.
		
	- Ir até a pasta vinho dentro de resources>template e criar uma nova página do tipo html.file prestando atenção para setar ela como html-5. Nome: pesquisa-vinhos.html
		- Colar a página de cadastro-vinho na página de pesquisa para utilizarmos o mesmo layout. 			
	- Para reutilizarmos código e deixarmos melhor nossa página vamos utilizar o layout-dialect que cria um layout reutilizavel.
	
	- Retirar da página de pesquisa e cadastro a div que informa que o sistema está "Carregando..."
	- O form terá a pesquisa implementada via GET.
	- Apagar os outros atributos da página, deixar somente a pesquisa por nome.
		- Também será utilizado o tipo de input com "div class= input-group" e "span class=input-group-btn" e acrescentar outro "span class= glyphicon-search".
		- Toda essa configuração tem no site do bootstrap como implementar esse tipo de pesquisa com botãozinho de pesquisa e placeholder, etc...
		
		
		<form method="GET" class="form-vertical>
			<div class="form-group">
				<div class="input-group">
					<input id="nome" type="text" class="form-control" placeholder="Pesquise pelo nome"/>
					<span class="input-group-btn">
						<button class="btn btn-default" type="submit">
							<span class="glyphicon  glyphicon-search"></span>
						</button>
					</span>
				</div>
			</div>
		</form>
			
	- Agora ir no VinhosController e acrescentar o método pesquisar().
	- Lembrando que para essa pesquisa, mais simples vamos utilizar os recursos do spring data jpa que já vem com vários metodos de pesquisa implementados e que somente
		precisamos fazer a chamada deles e utilizar. Relembrando eles estão sendo chamados no repository (interface).
	- Implementar o vinhos.findAll() para ver se está trazendo todos os registros corretamente.
	
		// Esse GetMapping tem que mudar para @GetMapping, pois agora a url "/vinhos" está sendo mapeada no cabeçalho da classe controller
		@GetMapping("/vinhos") // quando digitar essa url ele cai nesse método
		public ModelAndView pesquisar() {
			ModelAndView mv = new ModelAndView("/vinho/pesquisa-vinhos"); //este caminho está dentro da pasta vinho arquivo "pesquisa-vinhos".
			mv.addObject("vinhos", vinhos.findAll());
			return mv;
		}
	
	- Se observarmos ja existe muitos codigos duplicados com o "/vinhos". Já podemos melhorar isso.
	- Para isso vamos adicionar o @RequestMapping("/vinhos") em cima da assinatura da nossa classe VinhosController, e com isso todos os métodos que utilizarem a chamada
		a url que contenha "/vinhos" já virá por default.
		- Sendo assim não é mais necessário utilizar nos métodos a chamada a url contendo "/vinhos", pois agora todos já vem por default. Retirar dos métodos e no 
			método GET da pesquisa deixa sem nada.
			
				@Controller
				@RequestMapping("/vinhos")
				public class VinhosController { }
			
		- Até aqui então criamos a tela de pesquisa e implementamos a VinhosController para receber a chamada ao métode de pesquisa e melhoramos a reutilização
			de codigos acrescentando o @RequestMapping no cabeçalho da classe controller e também criamos a consulta .findAll() para trazer todos os nomes
			de vinhos cadastrados usando spring data jpa.
			
- Agora vamos desenvolver a parte no html 5 para exibir o resultado da pesquisa.
	
	- Precisamos receber um filtro no controller para receber esse nome do vinho e realizar a pesquisa e o metodo pesquisar no controller receber esse filtro "nome".
	- No package repository criar uma classe java dentro do pacote <repository> filter> com nome "VinhoFilter".
	- Os atributos que vamos criar nesse caso é somente pelo nome, então vamos criar o atributo nome do tipo String e gerando o getter e setter.
		- Esse filtro nome no package filter será amarrado na view thymeleaf de pesquisa, assim como na tela de cadastro os fieldes estão amarrados com o th:object.
			- Então no <form> da pesquisa-vinhos acrescentar o th:obejct="${vinhoFilter}", para deixar disponível para o formulário os objetos do vinhoFilter.
			- E no input acrescenta o th:field="*{nome}" para amarrar um campo a um atributo do objeto.
				- Assim quando for submeter a pesquisa vai deixar disponível esse objeto e os valores dele.
		
		- Então para pegar os valores desse objeto vamos até o VinhosController e acrescentamos ele no método de pesquisa como parametro. Dessa forma o spring
			já vai saber que está criando um objeto do tipo VinhoFilter e o spring entende isso. Além de que se o objeto já estiver vindo setado com algum
			valor no field do formulario html o spring já cria o objeto do tipo VinhoFilter e seta o valor do atributo do tipo nome.
			
		- Agora para criar a pesquisa passando o filtro nome é só ir até a interface Vinhos em repository e vamos criar uma pesquisa personalizada 
			com esse filtro nome.
			Lembrando, que todo método de uma interface é public. Sempre. Então em uma interface não é necessario colocar public na frente 
				de um método, como está feito abaixo, mas não tem importancia colocar.
			
		- Criar um List do pacote java util, vejamos como o spring data jpa é incrível.
		
			public List<Vinho> findByNomeContainingIgnoreCase(String nome);
			
			- Então essa pesquisa vai pesquisar por nome (findBy), containing (contendo qualquer letra, então ele coloca um % %, no fim e no começo do que 
				foi digitado no formulário) e o IgnoreCase (não importa se é maiusculo ou minusculo).
				
			- Ou poderia ficar.
			
				public List<Vinho> findByNomeAndTipoVinhoContainingIgnoreCase(String nome, TipoVinho tipo);
				
				- Lembrando que tem que ir passando os parametros, mas quando fica meio grande já começa ficar feio...rsss.
				
		- Voltando agora no VinhosController acrescentar no nosso método mv.addObject(.....) a nossa pesquisa para deixar disponivel essa nossa lista de vinhos.
		
			mv.addObject("vinhos", vinhos.findByNomeContainingIgnoreCase(
							Optional.ofNullable(vinhoFilter.getNome()).orElse("%")));
			
			- Optional começou no java 8, pois a página quando é carregada pode vir com o valor nulo, então caso venha com nulo ele passa % e traz todos os vinhos.
				Poderia ter feito um comparador ternario ou outra forma, mas assim fica bem legal.
				
			- Agora para ver se está funcionando é só ir na tela de pesquisa-vinhos no browser e digitar algum nome ou letra e verificar se ele
				está sendo exibido na url, se estiver funcionando tudo bonitinho será exibido na url, após o link principal.
	

- Criando a tabela para exibir o resultado da pesquisa.

	- Olhar em getbootstrap.com/css/#tables e escolher uma tabela para implementarmos na pesquisa-vinhos. Essa é uma table-responsive.
	- Colar o código logo abaixo do </form>. 
	
		<div class="table-responsive">
			<table id="tabela-produtos" class="table  table-striped  table-bordered  table-hover  table-condensed  js-sticky-table">
				<thead class="aw-table-header-solid">
					<tr>
						<th class="av-table-vinhos-col-codigo">Código</th>
						<th>Nome</th>
						<th class="av-table-vinhos-col-tipo">Tipo</th>
						<th class="av-table-vinhos-col-valor">Valor</th>
						<th class="av-table-vinhos-col-icons" sec:authorize="hasRole('ROLE_CADASTRAR_VINHO')"></th>
					</tr>
				</thead>
				<tbody>
					<tr th:each="vinho : ${vinhos}">
						<td th:text="${vinho.codigo}" class="text-center">1</td>
						<td>
							<a th:href="@{/vinhos/{codigo}(codigo=${vinho.codigo})}" th:text="${vinho.nome}" sec:authorize="hasRole('ROLE_CADASTRAR_VINHO')"></a>
							<span th:text="${vinho.nome}" sec:authorize="not hasRole('ROLE_CADASTRAR_VINHO')"></span>
						</td>
						<td th:text="#{|tipoVinho.${vinho.tipo}|}">Tinto</td>
						<td th:text="|R$${{vinho.valor}}|" class="text-right">55,00</td>
						<td class="text-center" sec:authorize="hasRole('ROLE_CADASTRAR_VINHO')">
							<i class="fa  fa-trash" style="cursor:pointer"
								data-toggle="modal" data-target="#confirmaExclusaoModal"
								data:nome="${vinho.nome}" 
								data:url-apagar="@{/vinhos/{codigo}(codigo=${vinho.codigo})}"></i>
						</td>
					</tr>
					<tr th:if="${vinhos.empty}">
						<td colspan="5">Nenhum vinho cadastrado</td>
					</tr>
				</tbody>
			</table>
		</div>
		
	- Agora dentro do pacote src/main/resources - static/ criar uma pasta chamada stylesheets e dentro dela criar um novo file
		chamado "vinhos.css". Essas classes são usadas no table acima.
		
		.av-table-vinhos-col-codigo, .av-table-vinhos-col-icons {
			width: 60px;
			text-align: center;
		}
		
		.av-table-vinhos-col-tipo {
			width: 100px;
		}
		
		.av-table-vinhos-col-valor {
			width: 150px;
			text-align: right;
		}
		
	- Acrescentar no html o link do css.
		
		<link rel="stylesheet" type="text/css" href="@{/stylesheets/vinhos.css}"/>
		
	- Existe um porém, ao rodar o projeto ele está vindo como R$4.90, mas no formato de moeda brasileiro usamos 4,90, então
		o thymeleaf reconhece um padrão e transforma em formato portugues. É só acrescentar {{vinho.valor}} como no código abaixo.
		
		<td th:text="|R$${{vinho.valor}}|" class="text-right">55,00</td>
		
	- Testar a aplicação: Cadastrar alguns vinhos e depois fazer a pesquisa para ver se está pesquisando corretamente.
	
- Melhorando o layout para arrumar as duplicações de código e também deixar mais bonito nosso código.

	- Sera usado o layout-dialect.
	- Então dessa forma é deixado um layout que será chamado na página que formos criando, assim será utilizado somente uma vez nosso código.
	- Veja no pom.xml que já acrescentamos o <thymeleaf-layout-dialect>2.12 que será utilizado junto com a versão 3.0.3 do thymeleaf.
		
		<!-- SEMPRE QUE ATUALIZAR O THYMELEAF.VERSION TEM QUE ATUALIZAR O THYMELEAF DIALECT -->
		<thymeleaf.version>3.0.3.RELEASE</thymeleaf.version>
		<thymeleaf-layout-dialect.version>2.1.2</thymeleaf-layout-dialect.version>
		
	- Agora vamos criar nosso layout padrão:
		- Dentro da pasta templates criar uma pasta chamada <layout>.
		- Copiar a página de cadastro-vinho para dentro dessa pasta layout e renomear o arquivo para "layou-padrao".
		- Será utilizado algumas partes da pagina cadastro para fazer o layout padrão e o restante vamos apagando.
		- Para usar o layout é necessário acrescentar um novo namespace "xmlns:layout".
			xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
			
		- Dentro dessa página será deixado tudo que será de comum para as outras páginas que serão utilizadas no sistema.
			- Então continuará o cabeçalho e o menu.
			- Apagar tudo que estiver entre <section class="aw-layout-content  js-content" layout:fragment="conteudo"> apagar o que tem aqui </section>
				- Para poder usar/estender essa página padrão é que acrescentamos o layout:padrao e também o layout:fragment="conteudo", pois o código novo
					vai ficar dentro do <section>fica aqui o codigo da pagina</section>
					
		- Para utilizar esse layout padrão dentro da página de cadastro-vinho, por exemplo, é necessário acrescentar o namespace xmlns:layout também e agora uma
			novidade, o layout:decorated.
				
				xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
				layout:decorate="~{layout/layout-padrao}" // aqui diz que a página de cadastro-vinho será decorada com o layout-padrao
			
			- Apagamos o que está no layout padrao e quando começar o <section> da página de cadastro acrescentamos <section layout:fragment="conteudo">
			- Fazer o teste na pagina de cadastro de vinhos.
			
		- Agora podemos melhorar também a pagina de pesquisa, lembrando que no <head> tem um link para o css que pode ser deixado na página.
		
		- Ir no vinhos.css e renomar para pesquisa-vinhos.css. e lembrar de alterar também em pesquisa-vinhos.html
		
			- Excluir da pagina de pesquisa todo o código duplicado, assim como na pagina de cadastro e testar no browser.
			
- Vamos implemantar agora a EDIÇÃO.

	- A idéia é a seguinte, vamos utilizar a url que foi criada no table para acessar a edição do registro. Quando clicarmos no nome de algum vinho esse link
		passa o código do vinho na url que faz a pesquisa daquele vinho e retorna o registro completo para podermos editar.
		A url passa a ficar assim: localhost:8080/vinhos/2, por exemplo, onde esse 2 é o código do vinho.
	- Para criar essa url com thymeleaf é bem tranquilo, vá ate a página pesquisa-vinhos onde a table <tbody> é preenchida e onde está o href que forma o 
		link vamos acrescentar o th:href para usar o thymeleaf. O "@" é para resolver o contexto da aplicação, quando tiver.
		O {codigo} é um parâmetro variavel e precisa estar entre chaves {}. Agora para definir o valor desse parametro variavel uso (codigo = ${vinho.codigo}),
			essa variavel "vinho." vem do th:each, então a url {codigo} que será criada vai ser preenchida com o código que vai vir de (codigo = ${vinho.codigo}).
			Veja abaixo como ficou.
				
				th:href="@{/vinhos/{codigo}(codigo=${vinho.codigo})}"
				
		O trecho ficou assim:
			
			<tr th:each="vinho : ${vinhos}">
					<td th:text="${vinho.codigo}" class="text-center">1</td>
					<td>
						<a th:href="@{/vinhos/{codigo}(codigo=${vinho.codigo})}" th:text="${vinho.nome}" sec:authorize="hasRole('ROLE_CADASTRAR_VINHO')"></a>
						<span th:text="${vinho.nome}" sec:authorize="not hasRole('ROLE_CADASTRAR_VINHO')"></span>
					</td>
				
			- Testando, na tela é só ir na pesquisa e passar o mouse sobre o link e então observe que no canto inferior esquerdo vai aparecer a url com 
				o código da url que está aparecendo.
				
	- Se clicar não vai aparecer nada, pois não tem nada implementado ainda e para isso vamos no controller, pois ainda não temos nenhuma url mapeada 
		que recebe "vinhos/2", ou seja, uma url que recebe vinhos com um código.
	- Para implementar usamos o model and view editar() que tem anotação @GetMapping que recebe uma variavel para compor a url.
	
		@GetMapping("/{codigo}")
		public ModelAndView editar() { }
		
		Definimos para o mapeamento Get uma variavel para ser acrescentada após a parte "/vinhos". O que está entre {} é a variavel que está vindo do 
			field que th:href que mapeamos no html.
	
	- Agora para o método editar saber que o código que vem do get será usado para fazer a pesquisa do vinho e trazer o vinho referente ao código passado,
		fazemos o seguinte.
		
			@GetMapping("/{codigo}")
			public ModelAndView editar(@PathVariable Long codigo) { 
				Vinho vinho = vinhos.findOne(codigo);
				return novo(vinho);
				
			- @PathVariable: Informa que o parametro Long codigo vai receber o valor que vier do @GetMapping {codigo}
			- Para pesquisar o vinho e trazer somente um registro que será o que iremos utilizar para editar usamos ".findOne()" que traz somente um 
				vinho específico.
			- return(novo) funciona para trazer a página de cadastro de vinho com os dados preenchidos com o que veio da pesquisa .findOne(). Então 
				a pagina será preechida com as informações do vinho para que possam ser editadas. Já estamos passando um vinho preechido.
					
	
				
		